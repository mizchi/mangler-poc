import path from "node:path";
import fs from "node:fs";
import process from "node:process";
import { parseArgs } from "node:util";
import ts from "typescript";
import { collectProperties, getLocalAmbientModules } from "../analyzer.mjs";
import { bundleDts } from "../generator.mjs";
import { createLoadedProjectWatcher, getTsconfigPath } from "../tsHelper.mjs";

export async function analyzeDts() {
  const tsconfigPath = getTsconfigPath();
  const watcher = await createLoadedProjectWatcher(tsconfigPath!);
  try {
    const cwd = process.cwd();
    const args = parseArgs({
      args: process.argv.slice(3),
      options: {
        config: {
          type: "string",
          short: "c",
          default: "packelyze.config.json",
        },
        input: {
          type: "string",
          short: "i",
        },
        output: {
          type: "string",
          short: "o",
        },
        external: {
          type: "string",
          default: [],
          short: "e",
          multiple: true,
        },
        builtins: {
          type: "string",
          multiple: true,
          short: "b",
        },
        writeDts: {
          type: "string",
          short: "w",
        },
        debug: {
          type: "boolean",
          default: false,
          short: "d",
        },
      },
      allowPositionals: true,
    });
    const builder = watcher.getProgram();
    const program = builder.getProgram();
    const checker = program.getTypeChecker();

    // let input: string;
    let argsValues = args.values;
    if (args.values.config) {
      const configPath = path.join(cwd, args.values.config);
      if (fs.existsSync(configPath)) {
        try {
          const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
          argsValues = {
            ...argsValues,
            ...config,
            // override: prefer input and output
            input: args.values.input || config.input,
            output: args.values.output || config.output,
          };
        } catch (e) {
          console.info("[packelyze] skip by parse error - packelyze.config.json", e);
        }
      } else {
        console.info("[packelyze] skip loading packelyze.config.json");
      }
    }

    if (argsValues.input == null) {
      console.error("input (-i) is required");
      process.exit(1);
    }

    const input = path.join(cwd, argsValues.input!);

    const debug = argsValues.debug;
    const writeDts = argsValues.writeDts;

    const dtsCode = await bundleDts({
      input,
      external: argsValues.external || [],
      respectExternal: argsValues.external != null,
    });

    // Emit dts
    if (writeDts) {
      console.log("// Generated by packelyze");
      const dtsPath = path.join(cwd, writeDts);
      fs.writeFileSync(dtsPath, dtsCode);
      console.log("[packelyze:analyze-dts:generate]", dtsPath.replace(cwd + "/", ""));
    }

    const source = ts.createSourceFile("_bundled.d.ts", dtsCode, ts.ScriptTarget.Latest, true);

    const localResult = collectProperties(source, undefined, debug);

    const buitinsSet = new Set<string>();

    // include builtins
    if (argsValues.builtins) {
      // @ts-ignore
      const builtins = await import("../../gen/builtins.mjs");
      for (const builtinName of argsValues.builtins) {
        if (builtinName in builtins) {
          console.log("[packelyze:analyze-dts:include-builtins]", builtinName, builtins[builtinName].length);
          for (const builtinProp of builtins[builtinName]) {
            buitinsSet.add(builtinProp);
          }
        }
      }
    }

    // ==== Static Analysis from Source ===

    // include ambient files
    // TODO: need active search in src/**/*.d.ts ?
    // analyze local ambient modules
    const localAmbientModules = getLocalAmbientModules(program, cwd);
    if (debug) {
      console.log(
        "[packelyze:analyze-dts:local-ambient-modules]",
        // checker.getAmbientModules().length,
        checker
          .getAmbientModules()
          .filter((m) => {
            const s = m.valueDeclaration?.getSourceFile();
            if (!s?.fileName.includes("/node_modules/")) {
              return true;
            }
            return false;
          })
          .map((m) => {
            return m;
          }),
        program
          .getSourceFiles()
          .filter((m) => {
            return m.fileName.endsWith(".d.ts") && !m.fileName.includes("/node_modules/");
          })
          .map((m) => {
            return m;
          }),
        // localAmbientModules.map((m) =>
        //   m.module.fileName.replace(cwd + "/", "")
        // ),
      );
    }
    const amibentGlobals = new Set<string>();
    for (const ambient of localAmbientModules) {
      const ambientResult = collectProperties(
        ambient.module,
        {
          ambient: true,
          mode: ambient.isolated ? "isolated-ambient" : "module-source",
        },
        debug,
      );
      for (const builtinProp of ambientResult.reserved) {
        amibentGlobals.add(builtinProp);
      }
      console.log(
        "[packelyze:analyze-dts:include-local-ambient]",
        ambient.module.fileName.replace(cwd + "/", ""),
        ambientResult.reserved.length,
      );
    }

    if (argsValues.output) {
      const outpath = path.join(cwd, argsValues.output);
      console.log("[packelyze:analyze-dts:generate]", outpath.replace(cwd + "/", ""));
      fs.writeFileSync(
        outpath,
        JSON.stringify(
          {
            local: [...localResult.reserved].sort(),
            localGlobals: [...amibentGlobals].sort(),
            reserved: [...buitinsSet, ...localResult.reserved, ...amibentGlobals].sort(),
            privates: localResult.privates.sort(),
          },
          null,
          2,
        ),
      );
    } else {
      console.log(JSON.stringify(localResult, null, 2));
    }
  } catch (err) {
    console.error(err);
  } finally {
    watcher.close();
  }
}
